# Adapter Pattern 
> Adapter 패턴은 호환되지 않는 인터페이스가 있는 객체가 협업할 수 있도록 돕는 Structural Design Pattern 입니다. 

# 예시로 알아보는 어댑터 패턴의 필요성 

## 문제상황 
![Adapter.png](..%2Fimages%2Fadapter%2FAdapter.png)

XML 기반으로 주식데이터를 읽어들이는 서비스를 운영하고 있습니다.   
조금 더 나은 사용자 경험을 주기 위해 보다 나은 타사의 라이브러리를 도입하려고 합니다.  
그런데 타사의 라이브러리는 JSON 기반으로 주식 데이터를 읽어들입니다.   
그렇기 때문에 신규 라이브러리를 도입하지 못하는 상황에 처해있습니다. 이럴 때 어떻게 해야 할까요?

## 해결책

`어댑터`를 사용해 해당 문제를 해결 할 수 있습니다.  
![Adapter2.png](..%2Fimages%2Fadapter%2FAdapter2.png)

호환이 되지 않는 문제를 XML to JSON Adapter를 사용해 문제를 해결 할 수 있습니다.  
신규 라이브러리는 XML 기반의 데이터를 직접 읽어들이지 않아도 됩니다.   
신규 라이브러리는 어댑터를 통해 JSON 으로 변환된 데이터만 수신하면 됩니다.  


어댑터는 다른 객체가 이해할 수 있도록 한 객체의 인터페이스를 변환해주는 역할을 합니다.  
어댑터는 객체 중 하나를 Wrapping 해 배후에서 발생하는 변환의 복잡성을 숨길 수 있습니다.   
어댑터의 예시는 다음과 같습니다.   
- 길이 단위 km / m --> Adapter --> 영국식 단위로 변환 
- 220V 전원 케이블 --> Adapter --> 110V 충전

## 어댑터 패턴 구조 
#### Object Adapter

![Adapter3.png](..%2Fimages%2Fadapter%2FAdapter3.png)

Object adapter 패턴의 경우 어댑터는 인터페이스를 구현하고 다른 개체를 래핑하는 방식으로 구현됩니다.

#### Class Adapter

![Adapter4.png](..%2Fimages%2Fadapter%2FAdapter4.png)

Class Adapter의 경우 상속을 사용합니다.  
어댑터는 동시에 두 개체에서 인터페이스를 상속합니다.  
(C++과 같이 다중 상속을 지원하는 프로그래밍 언어에서만 가능하다고 합니다.)



## 적용 가능성 
- 일부 기존 클래스를 사용하려고 하는데 해당 인터페이스가 나머지 코드와 호환되지 않는 경우 
- 슈퍼클래스에 추가할 수 없는 일부 공통 기능이 부족한 여러 기존 서브클래스를 재사용하려는 경우

## 장점 및 단점
##### 장점 
- 단일 책임 원칙
  - 기존 코드가 하던 일과 특정 인터페이스 구현체로 변환하는 작업을 각기 다른 클래스로 분리해 관리할 수 있다.
- 개방 / 폐쇄 원칙
  - 기존 코드를 변경하지 않고 원하는 인터페이스 구현체를 만들어 재사용할 수 있다. 

##### 단점
- 새 클래스가 생기므로 복잡도가 증가할 수 있다. 

---
출처 : [Refactoring Guru](https://refactoring.guru/design-patterns/adapter)
