# Proxy Pattern
> 프록시 패턴은 Structural Design Pattern으로 다른 객체의 대체자 역할을 제공합니다.   
> 프록시패턴은 객체로의 접근을 제한 할 수 있으며, 실제 객체가 일을 하기 전 후로 행동들을 추가할 수 있습니다. 

## 예시로 알아보는 프록시 패턴의 필요성

### 문제 상황
![proxy1.png](..%2Fimages%2Fproxy1.png)

그림과 같이 많은 리소스를 잡아먹는 클래스가 있습니다. (보통 데이터베이스에 쿼리를 날리는 경우 느릴 수 있습니다.)  
이 클래스는 때때로 필요하지만 매번 필요한 것은 아닙니다.   
***이러한 경우 프록시 패턴을 적용하면 많은 것을 해결 할 수 있습니다.***

### 문제 해결 
![proxy2.png](..%2Fimages%2Fproxy2.png)

프록시 패턴은 원래 서비스 클래스를 사용해 새로운 프록시 클래스를 만듭니다.  
그런 후 모든 클라이언트 요청은 앞으로 프록시 클래스가 역할을 담당합니다.   
프록시 패턴은 기존 코드의 변경 없이 부가적인 기능들을 추가할 수 있습니다.   
##### 예시 
- 프록시 클래스에서 요청 전후로 로깅을 남긴다.
- 로직이 걸리는 시간을 측정한다. 

## 프록시 패턴의 구조 
![proxy3.png](..%2Fimages%2Fproxy3.png)
##### ServiceInterface
- 프록시 패턴과 실제 Service를 구현할 수 있도록 만든 인터페이스. 

##### Service
- 유용한 비즈니스 로직을 제공하는 클래스. 

##### Proxy 
- Service 객체를 가르키는 참조 필드가 존재한다. 
- 프록시에서 원하는 로직들을 처리한다. 
  - 로깅
  - 액세스 제어 
  - 캐싱 
  - ... (원하는 로직들을 넣으면 됩니다)

## 적용 가능성 
- 지연초기화
  - 자주 필요하지 않지만 항상 가동되어 시스템 리소스를 낭비하는 무거운 서비스 개체가 있는 경우 
- 액세스 제어
  - 특정 클라이언트만 서비스 개체를 사용할 수 있도록 하려는 경우 
- 원격 서비스의 로컬 실행 
  - 서비스 개체가 원격 서비스에 있는 경우 
- 로깅 요청
  - 서비스 개체에 대한 요청 기록을 유지하려는 경우

## 프록시 패턴의 장점 및 단점 

##### 장점 
- 클라이언트가 알지 못하는 사이에 서비스 개체를 제어할 수 있다.
- 서비스 개체의 수명 주기를 관리할 수 있다. 
- 서비스 개체가 준비되지 않았거나 사용할 수 없는 경우에도 동작한다.
- OCP : 서비스 혹은 클라이언트를 변경하지 않고 새 프록시를 도입할 수 있다. 

##### 단점 
- 코드의 복잡도가 올라간다.
- 서비스의 응답이 지연될 수 있다. 

--- 출처   

[Refactoring Guru](https://refactoring.guru/design-patterns/proxy)
